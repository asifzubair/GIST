#' Read in MEX format data produced by Spaceranger
#' source:
#' https://support.10xgenomics.com/spatial-gene-expression/software/pipelines/latest/output/matrices
#' @param matrix_dir Directory containing counts, barcode and features
#' @return A dataframe of genes counts. Columns represet spots.
#' @export
load10xMatrix <- function(matrix_dir) {
  barcode.path <- file.path(matrix_dir, 'barcodes.tsv')
  features.path <- file.path(matrix_dir, 'features.tsv')
  matrix.path <- file.path(matrix_dir, 'matrix.mtx')
  mat <- Matrix::readMM(file = matrix.path)
  feature.names = read.delim(features.path,
                             header = FALSE,
                             stringsAsFactors = FALSE)
  barcode.names = read.delim(barcode.path,
                             header = FALSE,
                             stringsAsFactors = FALSE)
  colnames(mat) = barcode.names$V1
  rownames(mat) = feature.names$V2
  return(mat)
}

#' Read in the tissue positions file produced by Spaceranger
#' Ensures consistent columnn nomenclature
#' @param tp_file Tissue positions file generated by Spaceranger
#' @return a dataframe of tissue positions.
#' @export
load10xTP <- function(tp_file) {
  columns <- c('barcode', 'in_tissue', 'array_row', 'array_col', 'pxl_col', 'pxl_row')
  tp <- read.csv(tp_file,
                 col.names = columns,
                 row.names = 1)
  return(tp)
}


#' Impute, filter and normalize expression matrix
#'
#' Given a matrix of SC/ST counts, this function will
#' impute gene counts using knn_smoothing
#' filter based on criteria that gene has
#' 2 reads in atleast 10 cells
#' and finally, normalize the matrix using the chosen method
#' @param counts_mat Dataframe of counts, cells are columns, genes are rows
#' @param impute Logical indicating whether imputation should be done (default: TRUE)
#' @param k Number of nearest neighbours to aggregate (default: 5)
#' @param d Number of principal components (default: 10)
#' @param seed seed to be passed to knnSmooth algorithm
#' @param doQC Should we do filtering (default: FALSE)
#' @param normalize Do one of 'scale, scale-quantile, quantile, sct' normalization (default: None)
#' @param only_hvg Return only HVG from SCTransform (default: TRUE)
#' @return a matrix of gene counts
#' @export
preprocess_expr_mat <- function(counts_mat, impute = TRUE, k = 5, d = 10, seed = 42,
                                doQC = FALSE, normalize = NULL, only_hvg = TRUE){

  if (impute){
    message('Smoothing with ', k, ' neighbours and ', d, ' dimensions ...')
    counts_mat <- knn_smoothing(as.matrix(counts_mat),
                                k = k, d = d,
                                seed = seed)
  }

  if (doQC) {
    message('Performing filtering ...')
    genes <- which(rowSums(counts_mat > 2) > 10)
    counts_mat <- counts_mat[genes, ]
  }

  if (!is.null(normalize)){
    stopifnot(normalize %in% c('scale', 'quantile', 'scale-quantile', 'sct'))
    message('Performing ', normalize, ' normalization ...')
    counts_mat <- normalize.decon(counts_mat,
                                  doQC = F,
                                  method = normalize, only_hvg = only_hvg)
  }

  return(counts_mat)

}


#' Normalize a genes by cell matrix, and
#' optionally perform some QC
#' @param data A genes x cell matrix
#' @param doQC Should QC be performed: min.cells = 10%, min.features = 500
#' @param method Choose a method from 'scale', 'quantile', 'scale-quantile', 'sct'
#' @param only_hvg If using method 'sct', return only highly variable genes after normalization
#' @return a matrix of normalized gene counts
normalize.decon <- function(data,
                            doQC = FALSE,
                            method = c('scale', 'quantile', 'scale-quantile', 'sct'),
                            only_hvg = T){

  method = match.arg(method)
  if (method %in% c('scale', 'scale-quantile'))
    scale.factor = median(colSums(data))

  if (doQC){
    data <- Seurat::CreateSeuratObject(data,
                                       min.cells = 0.1*ncol(data),
                                       min.features = 500,
                                       assay = 'RNA')
  } else {
    data <- Seurat::CreateSeuratObject(data,
                                       min.cells = 0,
                                       min.features = 0,
                                       assay = 'RNA')
  }

  if (method == 'scale'){
    data <- Seurat::NormalizeData(data,
                                  normalization.method = 'RC',
                                  scale.factor = scale.factor)
    data <- as.data.frame(Seurat::GetAssayData(data,
                                               assay = 'RNA',
                                               slot = 'data'))
  } else if (method == 'quantile'){
    data <- as.data.frame(Seurat::GetAssayData(data,
                                               assay = 'RNA',
                                               slot = 'counts'))
    data <- normalize.quantiles2(data)

  } else if (method == 'scale-quantile'){
    data <- Seurat::NormalizeData(data,
                                  normalization.method = 'RC',
                                  scale.factor = scale.factor)
    data <- as.data.frame(Seurat::GetAssayData(data,
                                               assay = 'RNA',
                                               slot = 'data'))
    data <- normalize.quantiles2(data)
  } else if (method == 'sct') {
    if (only_hvg)
      message('SCT will return only HVG ...')
    data <- Seurat::SCTransform(data, assay = 'RNA', return.only.var.genes = only_hvg)
    data <- as.data.frame(Seurat::GetAssayData(data,
                                               assay = 'SCT',
                                               slot = 'scale.data'))
  }

  return(data)

}


#' Normalize quantiles wrapper
#' to handle loss of rownames
#' and colnames
#' @param counts_mat Matrix of counts to be normalized
#' @return a quantile normalzed of gene counts
normalize.quantiles2 <- function(counts_mat){
  RNs <- rownames(counts_mat)
  CNs <- colnames(counts_mat)
  convert = F
  if (!is.matrix(counts_mat)) {
    convert = T
    counts_mat <- as.matrix(counts_mat)
  }
  counts_mat <- preprocessCore::normalize.quantiles(counts_mat)
  rownames(counts_mat) = RNs
  colnames(counts_mat) = CNs
  if (convert) counts_mat <- as.data.frame(counts_mat)
  return(counts_mat)
}


#' Make signature matrix from
#' imputed, filtered, normalized
#' single cell counts
#' @param sc_counts A matrix/dataframe of single cell counts, with cells as columns and genes as rows
#' @param sc_labels A matrix/dataframe of cell type labels, two cols, one for cell and one for cell type
#' @param save_fname Optionally save the signature matrix
#' @return a matrix of gene expression means with genes as rows and cell types as columns
#' @export
make_signature_matrix <- function(sc_counts, sc_labels, save_fname = NULL){

  if (is.matrix(sc_counts)) sc_counts <- as.data.frame(sc_counts)
  if (is.matrix(sc_labels)) sc_labels <- as.data.frame(sc_labels)
  colnames(sc_labels) <- c('cell', 'bio_celltype')

  sig_mat <- sc_counts %>%
    t %>% as.data.frame %>%
    tibble::rownames_to_column('cell') %>%
    dplyr::inner_join(sc_labels, by = 'cell') %>%
    dplyr::select(bio_celltype, dplyr::everything()) %>%
    dplyr::select(-cell) %>%
    dplyr::group_by(bio_celltype) %>%
    dplyr::summarise_all(mean) %>%
    tibble::column_to_rownames('bio_celltype') %>%
    t %>% as.data.frame()

  if(!is.null(save_fname))
    saveRDS(sig_mat, file = save_fname)

  invisible(sig_mat)
}


#' Merge dataframe with tissue positions
#' internal function for plotting data
#' tp should be a dataframe with pxl_col, pxl_row
#' @param .data a dataframe with rownames as barcodes
#' @param tp a dataframe of tissue positions
#' @return a merged dataframe in long format
merge_with_locations <- function(.data, tp){
  .data <- .data %>%
    merge(tp[c('pxl_col', 'pxl_row')], by = 0) %>%
    tibble::column_to_rownames("Row.names") %>%
    tidyr::gather("type", "marker", -pxl_col, -pxl_row)
  return(.data)
}


#' Visualization of spots expression
#' across tissue for a single variable
#' @param df Spot by value matrix, spots are rows, values are cols
#' @param tp Matrix of spot locations, should contain
#'           pxl_col, pxl_row indicating column and row location of pixel
#' @param trans Any transformation that needs to be done to values - log10 etc. (default: "identity")
#' @param legend.label Label for the value legend (default: "Propr.")
#' @param size_m size of the spots to be plotted (default: 4)
#' @return plot showing spots according to tissue positions
#' @export
plot_spots0 <- function(df, tp, trans = 'identity', legend.label = 'Prop.', size_m = 4){
  p <- df %>%
    merge_with_locations(tp) %>%
    ggplot2::ggplot(aes(pxl_row, -pxl_col, color = marker)) +
    ggplot2::geom_point(size = size_m) +
    ggplot2::scale_colour_gradient(low="#f8d39f", high = "#800000", trans = trans) +
    ggplot2::theme(
      panel.grid.major = ggplot2::element_blank(),
      panel.grid.minor = ggplot2::element_blank(),
      strip.text = ggplot2::element_text(size = 14),
      axis.text = ggplot2::element_blank(),
      axis.title = ggplot2::element_blank(),
      axis.ticks = ggplot2::element_blank(),
      panel.background = ggplot2::element_rect(fill = "black")) +
    ggplot2::labs(colour = legend.label)
  return(p)
}


#' Visualization of spots with proportions of cell types
#' @param df Spot by value matrix, spots are rows, values are cols
#' @param tp Matrix of spot locations, should contain
#'           \code{pxl_col}, \code{pxl_row} indication column and row location of pixel
#' @param trans Any transformation that needs to be done to values - log10 etc.
#' @param legend.label Label for the value legend (default: "Prop.")
#' @param ncols number of columns
#' @param joint_scale Plot common legend scale (default: FALSE)
#' @param size_m Size of the spots to be plotted (default: 1)
#' @param my_theme gg_theme to be passed to ggplot
#' @return a visualization of supplied metrics according to tissues positions
#' @export
plot_spots <- function(df, tp, trans = 'identity', legend.label = 'Prop.', ncols = 3,
                       joint_scale = FALSE, size_m = 1, my_theme = NULL){
  default_theme <- ggplot2::theme(
    panel.grid.major = ggplot2::element_blank(),
    panel.grid.minor = ggplot2::element_blank(),
    axis.text = ggplot2::element_blank(),
    axis.title = ggplot2::element_blank(),
    axis.ticks = ggplot2::element_blank(),
    panel.background = ggplot2::element_rect(fill = "black"))
  if (is.null(my_theme)) my_theme = default_theme
  df <- df %>%
    merge_with_locations(tp)
  if (!joint_scale){
    p <-  df %>%
      dplyr::group_split(type) %>%
      purrr::map(
        ~ggplot2::ggplot(., ggplot2::aes(pxl_row, -pxl_col, color = marker)) +
          ggplot2::geom_point(size = size_m, shape=16) +
          ggplot2::scale_colour_gradient(low="#f8d39f", high = "#800000", trans = trans) +
          ggplot2::facet_wrap(~ type, labeller = function(x) ggplot2::label_value(x, multi_line = FALSE)) +
          ggplot2::labs(colour = legend.label) +
          my_theme
      ) %>%
      cowplot::plot_grid(plotlist = ., align = 'hv', ncol = ncols)
  } else {
    p <- df %>%
      ggplot2::ggplot(ggplot2::aes(pxl_row, -pxl_col, color = marker)) +
      ggplot2::geom_point(size = size_m, shape=16) +
      ggplot2::scale_colour_gradient(low="#f8d39f", high = "#800000", trans = trans) +
      ggplot2::facet_wrap(~ type, labeller = function(x) ggplot2::label_value(x, multi_line = FALSE), ncol = ncols) +
      my_theme +
      ggplot2::labs(colour = legend.label)
  }
  return(p)
}
